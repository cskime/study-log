# Architecture - Clean Architecture

> Clean Architecture 5부 21~22장

- 아키텍처는 시스템을 UseCase 중심으로 설명한다.
- 클린 아키텍처는,
    - 소프트웨어의 **관심사를 분리**하여 여러 계층으로 나눈다.
    - Entity는 가장 일반적이고 높은 수준의 정책으로, 가장 안쪽 계층에 위치한다.
    - 의존성 규칙을 준수해야 한다. (의존성 방향은 항상 경계선 안쪽으로 향해야 한다.)
    - 제어 흐름이 경계를 횡단할 때, 안쪽 계층에서 인터페이스를 제공하여 의존성 방향을 역전시킨다.
    - 경계를 횡단하는 데이터는 어떤 것에도 의존하지 않고 격리된 상태여야 한다.
        - 중복인 것 처럼 보여도, Entity나 다른 계층에 의존하면 안된다.
        - 이들은 시간이 지나면 서로 다른 이유와 속도로 변경되므로 중복이 아니다.

## 소리치는 아키텍처

- 소리친다 : 아키텍처를 볼 때 이 시스템이 어떤 것인지 알 수 있게 나타내는 것
- '이 아키텍처는 집이야'라고 소리쳐야 함
- '이 아키텍처는 벽도롤 지어진 집이야'라고 소리치면 안된다.
- 즉, **아키텍처는 application의 유스케이스에 대해 소리쳐야 한다.**
    - 상위 디렉터리 구조, 소스 파일을 볼 때 '헬스 케어 시스템이야' 또는 '재고 관리 시스템이야'라고 소리쳐야 한다.
    - 'Rais야', 'Spring이야', 'ASP야'라고 소리치면 안된다.
- 아키텍처가 프레임워크 같은 세부사항에 의존해서는 안된다. 프레임워크, DB, UI, 웹 서버 등 세부사항들에 대해 마지막까지 결정을 미룰 수 있어야 한다.
- Application이 웹으로 전달될지, 앱으로 전달될지에 대해 시스템 아키텍처는 아무것도 몰라야 한다.
- 프레임워크를 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.
    - 테스트를 위해 웹 서버가 반드시 필요한 상황이 되면 안된다.
    - 테스트를 위해 데이터베이스가 반드시 연결되어 있어야 하면 안된다.
    - Entity 객체가 세부사항에 의존해서는 안된다.

## 클린 아키텍처

- 시스템 아키텍처들의 공통 목표는 '**관심사의 분리(separation of concerns)**'
- 소프트웨어를 '**계층**'으로 분리하여 관심사의 분리를 달성한다.
- 두 계층은 반드시 포함한다.
    1. 업무 규칙 계층
    2. 사용자와 시스템 인터페이스를 위한 계층
- 소프트웨어를 계층으로 분리하여 관심사의 분리를 달성한 아키텍처들은 아래 특징을 갖는다. ('**독립성**'이 key point)
    1. 프레임워크 독립성 : 아키텍처가 프레임워크에 의존하지 않고 도구로서 사용할 수 있다.
    2. 테스트 용이성 : UI, DB 등 외부 요소 없이도 업무 규칙을 테스트할 수 있다.
    3. UI 독립성 : 시스템의 나머지 부분을 변경하지 않아도 UI를 쉽게 변경할 수 있다. (웹 UI를 콘솔 UI로 쉽게 교체할 수 있다.)
    4. DB 독립성 : 업무 규칙은 DB에 결합되지 않는다. 언제든 다른 DB로 교체할 수 있다.
    5. 외부 에이전시에 대한 독립성 : 업무 규칙은 외부와의 인터페이스에 대해 전혀 알지 못한다.

### 의존성 규칙

<p align="center"><img src="img/clean-architecture.jpeg" width="400"></p>

- 의존성 규칙 : **소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.**
    - 동심원의 안쪽으로 갈수록 고수준이다.
    - 바깥쪽 원은 매커니즘, 안쪽 원은 **정책**이다.
    - 내부 원에 속한 요소는 외부 원에 속한 것을 알지 못한다.
    - 내부 원에서는 외부의 클래스, 함수, 변수 등 어떤 것의 이름도 언급해서는 안된다
    - 내부 원에서는 외부에서 생성한 데이터 구조를 사용해서는 안된다.
- 의존성 규칙은 **외부 원에 위치한 어떤 것도 내부 원에 영향을 주지 않도록** 한다.

### Entity

- 핵심 업무 규칙(가장 일반적이고 고수준의 규칙) 캡슐화
- 다른 애플리케이션에서 재사용할 수만 있다면 형태는 중요하지 않다.
    - Method를 가진 객체 (클래스)
    - 데이터 구조와 함수의 집합 (구조체)
- 운영 관점에서 애플리케이션에 변경이 필요하더라도, Entity 계층에는 절대로 영향을 주면 안된다.

### UseCase

- Application 특화 업무 규칙
- Entity로 들어오고 나가는 데이터 흐름을 조정하고, Entity를 사용해서 UseCase의 목적을 달성하도록 만든다.
- UseCase에서 발생한 변경사항이 Entity에 영향을 주면 안된다.
    - 즉, Entity가 UseCase에 의존하면 안된다.
    - UseCase가 Entity에 의존해야 한다.
- 외부의 변경사항이 UseCase 계층에 영향을 주면 안된다.
    - DB, UI 등
- 운영 관점에서 애플리케이션이 변경된다면 UseCase 계층에 속한 소프트웨어가 영향을 받는다.
    - UseCase는 애플리케이션 특화 업무 규칙이기 때문

### Interface Adapter

- Adapter는 데이터를 UseCase와 Entity에게 가장 편리한 형식에서 DB나 UI같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.
    - UI로 전달하는 경우, Presenter, View, Controller 등이 여기에 속한다.
        - Presenter가 UseCase에서 사용하던 데이터를 View에 보여주기 좋은 형식으로 formatting
        - View는 사용자가 보기 좋은 방식으로 데이터를 보여준다.
        - 데이터는 '**Controller -> UseCase -> Presenter, View**'로 이동한다.
        - 데이터가 이동하는 과정에서, 각각에 더 편리한 방식으로 변환된다.
    - DB로 전달하는 경우,
        - Adapter가 SQL을 처리한다.
        - 모든 SQL은 Adapter 계층에서 DB를 담당하는 부분을 벗어나서는 안된다.
- 반대로, 외부 에이전시에 편리한 형식에서 내부 UseCase 및 Entity에 편리한 형식으로 변환하는 Adapter도 포함된다.

### Framework & Driver

- 동심원의 가장 바깥쪽 계층은 DB나 UI, Web Framework로 구성된다.
- 이 계층에는 모든 세부사항들이 위치한다.
    - UI
    - DB
- 세부사항을 가장 바깥쪽 원에 위치시켜서, 이 계층에서 발생한 변경사항에 의한 피해를 최소화한다.

### 원의 개수

- 원의 개수는 더 많아질 수도 있고, 적어질 수도 있다.
- '**소스 코드 의존성이 항상 안쪽으로 향하는**' 의존성 규칙만 지켜지면 된다.
    - 의존성이 안쪽으로 들어갈 수록 추상화와 정책의 수준이 높아진다.
    - 바깥쪽으로 갈 수록 저수준의 구체적인 세부사항으로 구성된다.
    - 가장 안쪽 계층은 가장 범용적이며 높은 수준을 가진다.

### 경계 횡단

- 계층과 계층 사이 경계를 횡단할 때,
    - 제어 흐름 : Controller -> UseCase -> Presenter
    - 의존성 : Controller -> UseCase <- Presenter
- UseCase와 Presenter와 같이, **의존성이 안쪽을 향하도록 제어 흐름과 반대 방향으로** 만들어야 할 때 DIP를 사용한다.
- 즉, **제어 흐름이 경계를 가로지를 때** DIP로 의존성을 제어 흐름의 반대로 역전시킨다.
- 제어 흐름을 역전시키는 방법
    - UseCase에서 Presenter를 직접 호출하면 안된다. (내부에서 외부 계층에 의존하게 되므로 의존성 규칙에 위배)
    - UseCase가 내부 원의 인터페이스(그림에서 'Output Port')를 호출하도록 하고, Presenter가 인터페이스를 구현하도록 만든다.
    - 이 때, OOP는 **동적 다형성을 손쉽게 구현**할 수 있게 해 주므로 가치가 생긴다.
- 즉, 경계를 횡단할 때 DIP를 사용해서 언제든지 제어 흐름을 역전시켜 의존성 규칙을 준수할 수 있다.

### 경계를 횡단하는 데이터

- 경계를 횡단할 때 전달되는 데이터는 단순한 데이터 구조로 이루어진다.
    - 일반 구조체
    - DTO(Data Trasnfer Object) 객체
    - Hash map
    - 기타 다른 객체
- 어떤 형태이든, **격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달**되어야 한다.
- 경계를 횡단하는 데이터 구조는 어떠한 의존성도 가지면 안된다.
    - VIP에서 V, I, P가 각 계층이 됨
    - 이 계층을 횡단할 때 전달하는 데이터가 Request, Response, ViewModel 세 가지로 격리되어 있음
    - 세 데이터 구조는 'UseCase'를 나타내는 타입(보통 `enum`)으로 분리되어 있음
    - 즉, **VIP에서는 UseCase를 중심으로 서술된 경계를 횡단하는 데이터 구조들이 잘 격리되어 있다.**
- 의존성 규칙에 따라 안쪽 계층으로 향할 때, 경계를 횡단하는 데이터는 항상 **내부 원에서 사용하기에 가장 편리한 형태**여야 한다.