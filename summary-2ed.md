# Sumary

<details>
<summary>Key concepts</summary>

## Keywords

### Object Design Principle

- SRP(Single Responsibility Principle)
  - 객체는 하나의 actor에 의해서만 변경되어야 한다.
  - 서로 다른 속도와 이유로 변경되는 행위를 분리해야 한다.
- OCP(Open Close Principle)
  - 확장에 열려있고 변경에 닫혀 있어야 한다.
  - 기존 코드를 수정하기보다 새로운 객체로 교체할 수 있는 확장성을 가져야 한다.
- LSP(Liskov Subsitution Principle)
  - 어떤 하위 타입으로도 치환할 수 있어야 한다.
- ISP(Interface Segregation Principle)
  - 실제로 사용하지 않는 것에 의존하지 않도록 인터페이스로 분리해야 한다.
- DIP(Dependency Inversion Principle)
  - 구체 컴포넌트가 항상 추상 컴포넌트에 의존하도록 의존성 방향을 제어 흐름에 역전시켜야 한다.

### Component Cohesion

- REP(Reuse/Release Equivalence Principle)
  - 재사용 단위는 릴리스 단위와 같다.
  - 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 한다.
- CCP(Common Closure Principle)
  - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶는다.
  - 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리한다.
- CRP(Common Reuse Principle)
  - 필요하지 않는 것에 의존하지 않아야 한다.
  - 같이 재사용되는 경향이 있는 클래스와 모듈을 같은 컴포넌트에 포함해야 한다.

### Component Coupling

- ADP(Acyclic Dependencies Principle)
  - 의존성 그래프가 순환하지 않도록 설계하라
  - 순환이 발생하면 의존성을 끊을 수 없고, 순환을 만드는 컴포넌트들이 하나의 거대한 컴포넌트가 되어 유지보수를 어렵게 만든다.
  - DIP를 사용하는 등 순환을 끊어야 한다.
- SDP(Stable Dependencies Principle)
  - 더 안정된 방향으로 의존하라
  - 안정된 컴포넌트 : 불안정성 `I = out / (in + out)`에 대해 `I = 0`인 컴포넌트
  - Out이 0이다 == 다른 컴포넌트에 의존하지 않는다 == 외부 요소에 의해 변경되지 않는다 == 안정되었다.
- SAP(Stable Abstractions Principle)
  - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
  - 추상화 정도 `A = Na / Nc`에 대해 `I`와 `A` 사이에 주계열 그래프가 형성된다.
  - 주계열로부터의 거리 `D = |A + I - 1|`에 대해 `D`가 0에 가까울 수록 이상적이다.
- SDP와 SAP : **안정된 컴포넌트는 추상 컴포넌트여야 한다고 말하며, 항상 추상 컴포넌트에 의존해야 한다.**

### 비교

- SRP와 CCP : 동일한 시점에 동일한 이유로 변경되는 것들을 하나로 묶어라
  - SRP : 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라
  - CCP : 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라
- ISP와 CRP : 필요하지 않은 것에 의존하지 말라
  - ISP : 사용하지 않는 메서드가 있는 클래스에 의존하지 말아라
  - CRP : 사용하지 않는 클래스가 있는 컴포넌트에 의존하지 말아라

</details>

## 17장. 경계: 선 긋기

- 아키텍처는 '선 긋기' 기술
- 선(또는 경계) : 고수준 업무 규칙을 저수준 세부사항(UI, DB 등)과 분리시키는 경계
- UI, DB 등은 외부 요인에 의해 비교적 자주 변경되는데, 이 변경사항이 핵심 업무 규칙에까지 영향을 주지 않도록 격리시키는 것
- 경계를 구분함으로써 고수준 컴포넌트가 저수준 컴포넌트를 플러그인처럼 사용하게 됨 => 플러그인 아키텍처
- 저수준 컴포넌트를 플러그인처럼 사용하므로, 저수준 컴포넌트의 구체적인 구현 방식에 대한 결정을 최대한 뒤로 미룰 수 있다. 
  - Realm과 CoreData 중 어떤 것을 사용할 것인지?
  - UIKit과 SwiftUI중 어떤 것을 사용해서 UI를 개발할 것인지?
- 이 과정에서 두 가지 원칙이 적용됨
  - DIP : 고수준 컴포넌트가 저수준 컴포넌트를 사용할 때, 제어 흐름과 반대되는 의존성 방향을 갖도록 만들어서 분리한다.
  - SAP : 불안정한 저수준 컴포넌트가 안정된 고수준의 추상 컴포넌트에 의존하도록 만든다.

## 18장. 경계 해부학

- 경계를 사용해서 변경사항이 고수준 컴포넌트로 전파되는것을 막을 때, OOP의 다형성이 중요한 역할을 함
- OOP의 동적 다형성은 의존성 역전을 안전하고 쉽게 구현할 수 있게 함
- 의존성을 역전시킬 때, 인터페이스에서 필요한 데이터 구조는 호출하는 쪽에서 정의하게 됨. => DS는 고수준 컴포넌트에 포함된다.
- 경계는 고수준 컴포넌트를 저수준 세부사항으로부터 독립적으로 유지할 수 있게 해 준다.

## 19장. 정책과 수준

- 정책 : 소프트웨어 시스템의 동작을 설명하는 단위
- 수준 : 입력 및 출력까지의 거리. 멀리 떨어져 있을 수록 고수준.
  - 스마트폰에서 입력과 출력은 UI, DB, Server 등에 해당 -> 저수준
  - 업무 규칙은 상대적으로 고수준에 해당
- 동일한 이유로 동일한 시점에 변경되는 정책들을 같은 컴포넌트로 묶어야 한다.
- 컴포넌트들 사이의 의존성 관계는 비순환 방향 그래프를 형성하며, 의존성은 항상 저수준에서 고수준을 향하도록 설계해야 한다.
  - 즉, 의존성은 '수준'에 따라 결합된다.
- 모든 의존성이 저수준에서 고수준으로 향하는 지점에서 수준을 나누는 경계가 그어진다.

## 20장. 업무 규칙

- 소프트웨어와 관계 없이 사업적 수익을 얻거나 비용을 줄일 수 있는 규칙
- 엔티티(Entity) : 사업 특화 업무 규칙
  - 핵심 업무 규칙 : 사업 자체에 핵심적이며 규칙을 자동화하는 시스템이 없더라도 존재하는 규칙 (e.g. 대출에 N%의 이자를 부과한다.)
  - 핵심 업무 데이터 : 핵심 업무 규칙이 존재하기 위해 필요한 데이터 (e.g. 이자율, 대출 잔액 등)
  - 엔티티는 핵심 업무 규칙(method)과 핵심 업무 데이터(property)를 묶어놓은 독립된 모듈(struct, object)
  - DB, UI, third party framework 등 외부 요인에 의해 변경되어서는 안됨
- 유스케이스(Use case) : 애플리케이션 특화 업무 규칙
  - 엔티티를 언제, 어떻게 호출할지 명시하여 사용자와 상호작용하는 방식을 규정한다.
  - (e,g, 시스템에서 신상정보 화면을 모두 채우고 신용도가 검증된 후에 대출 견적 화면으로 이동한다.)
  - UI에 독립적이므로, use case만 봐서는 어떤 형식의 프로그램인지 알 수 없다. (e.g. 앱인지, 웹인지, 순수 서비스인지)
- 엔티티는 유스케이스에 대해 아무것도 알지 못한다.
  - 유스케이스는 입출력에 더 가까이 위치하므로 엔티티보다 저수준
  - 저수준 -> 고수준 으로 의존성을 설계해야 하므로 엔티티는 유스케이스에 대해 아무 것도 알 수 없다.
- 유스케이스는 요청(request) 및 응답(response) 모델을 독립적으로 가져야 한다.
  - 엔티티와 요청/응답 모델이 똑같이 생겼지만, 같이 사용하면 안된다.
  - 이들은 완전히 다른 속도와 이유로 변경되므로 CCP와 SRP에 위배된다.

## 21장. 소리치는 아키텍처

- 아키텍처는 애플리케이션의 유스케이스에 대해 소리쳐야 한다.
- 아키텍처가 유스케이스를 중심에 두어야 프레임워크, DB, Server, UI 등 세부사항을 오랫동안 선택사항으로 남겨둘 수 있다.
- 프레임워크 없이 애플리케이션의 모든 유스케이스에 대해 단위 테스트를 할 수 있어야 한다. -> Testability
- 새로 합류한 프로그래머는 시스템이 어떻게 전달될지 알지 못한 상태에서도 모든 유스케이스를 이해할 수 있어야 한다.

## 22장. 클린 아키텍처

<img src="img/clean-architecture.jpeg" width="500">

- 아키텍처는 업무규칙, UI, DB, Server, Framework 등을 '**계층**'으로 분리하여 '**관심사의 분리**'라는 목표를 달성한다.
- 관심사의 분리를 통해 업무 규칙의 '**독립성**'과 시스템의 '**테스트 용이성**'의 이점을 얻는다.
- '**의존성 규칙**'에 따라, 분리한 계층들 사이에 의존성 방향은 저수준에서 고수준 계층으로 향해야 한다.
- 계층들을 안쪽으로 갈수록 고수준 계층으로 배치하여, 의존성 방향이 항상 내부로 향하는 동심원 다이어그램을 그린다.
- 다이어그램에서 원의 개수는 네 개보다 더 많이 또는 더 적게 필요할 수도 있다.
- Enterprise Business Rules (Entities)
  - 전사적인 핵심 업무 규칙 또는 애플리케이션의 가장 일반적이며 고수준인 규칙
  - 같은 업무 규칙을 갖는 다른 소프트웨어에서 '**재사용**'할 수 있어야 한다.
  - 운영 관점에서 변경이 필요하더라도 엔티티는 영향을 받지 않는다.
- Application Business Rules (Use cases)
  - 엔티티를 사용해서 애플리케이션에 특화된 업무 규칙을 정의하고 목적을 달성한다.
  - 운영 관점에서 애플리케이션이 변경되는 경우에만 영향을 받는다.
- Interface Adapters
  - 데이터의 형태를 아래 두 가지 케이스에 편리한 형태로 상호 변환하는 코드가 포함된다.
      - Entity 및 Use Case에서 사용하는 데이터 형태
      - DB, UI 등 외부 agency에서 사용하는 데이터 형태
  - 단, DB, UI 등 세부 사항들을 직접적으로 알아서는 안된다.
  - Controller, Presenter 등 MVC, MVVM 아키텍처 패턴들을 모두 포함한다.
- Frameworks & Drivers
  - UI, DB 등 세부사항을 붙이는 계층
- 위의 4개 계층 경계를 횡단할 때, 의존성 규칙을 위배하지 않도록 인터페이스를 사용해서 의존성을 역전시켜야 한다.
  - 제어 흐름 : Controller -> Use Case -> Presenter
  - 의존성 : Controller -> Use Case <- Presenter
  - Use Case가 데이터를 Presenter에 전달할 때 Presenter의 코드를 호출해야 하므로 제어 흐름은 UseCase -> Presenter로 흐름
  - 의존성 규칙에서는 Presenter -> UseCase로 의존성 방향이 향해야 하므로, **동적 다형성**을 이용하여 의존성 방향을 역전시킨다.
- 경계를 횡단하는 데이터의 구조는 내부 원에서 사용하기 편리한 형태를 가져야 한다. (== 외부 원의 무언가에 의존하고 있으면 안된다.)

## 23장. 프레젠터와 험블 객체

- Presenter : 데이터를 화면에 출력할 수 있는 형태로 재구성하는 역할
- 험블 객체(Humble Object) 패턴
  - 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 분리하는 패턴
  - 험블 객체 : 테스트하기 어려운 행위를 모아둔 객체 또는 모듈
  - 험블 객체 패턴에 의해 분리된 두 모듈 사이에 아키텍처 경계가 형성된다.
- UI 관점에서 보면,
  - UI 자체를 테스트하기는 어려우므로 View는 험블 객체
  - 데이터를 화면에 표시하기 위한 형태로 변환하는 테스트하기 쉬운 행위들을 Presenter로 옮겨서 테스트
  - View와 Presenter 사이에 경계가 형성되고, interface를 통해 의존성이 분리된다.
- DB 관점에서 보면,
  - DB 자체에 직접 접근하는 gateway 구현체는 험블 객체
  - 필요한 데이터를 가져오는 테스트하기 쉬운 행위들을 Interactor로 옮겨서 테스트
  - DB와 Interfactor 사이에 경계가 형성되고, interface를 통해 의존성이 분리된다.
- 험블 객체 패턴에서 험블 객체를 stub 또는 test doubles로 교체해서 테스트할 수 있다.
- Data Mapper
  - DB로부터 가져온 데이터를 데이터 구조에 맞게 담는 역할을 하는 객체
  - 이것은 DB 계층에 위치해야 한다.
  - DB 계층에서 Interactor로 전달할 데이터 구조를 생성해서 반환하게 될 것
- 즉, 험블 객체 패턴은 각 경계마다 사용되어 테스트하기 쉬운 행위를 험블 객체로부터 분리해 내고 testability를 높인다.
  - UI : Presenter와 View
  - DB : Interactor와 DB 구현체
  - 험블 객체는 각 영역에서의 **구체적인 구현체**

## 24장 부분적 경계

- 아키텍처를 완벽하게 구현하는게 너무 과하다고 생각될 때 '부분적 경계'를 고려해 볼 수 있다.
- 부분적 경계 구현 방법
  1. 단일 컴포넌트
    - 독립적으로 컴파일 및 릴리즈 할 수 있도록 구현하되 하나의 컴포넌트만 구현한다.
    - 다수의 컴포넌트를 관리하는 부담을 던다.
  2. 일차원 경게
    - Strategy pattern 등을 사용하여 client가 service implementation에 직접 접근하지 못하도록 한다.
    - Service impl class가 격리를 위해 사용되는 interface를 무시하고 client에 직접 의존할 위험을 내포한다.
  3. 퍼사드 패턴 활용
    - 의존성 경계도 무시한채 client가 facade class를 통해서만 service class에 접근하도록 만든다.
    - Client와 client는 분리된 것 처럼 보이지만 추이 종속성이 형성되어 의존성 규칙을 위배한다.
- 항상 완벽한 아키텍처를 설계하기보다 상황에 따라 부분적으로 구현하는 것을 고려해 볼 수 있다.
  - 아키텍처 경계가 언제, 어디에 존재할지?
  - 경계를 완벽하게 또는 부분적으로 구현할지?
     