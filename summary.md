# Sumary

## Keywords

### Object Design Principle

- SRP(Single Responsibility Principle)
  - 객체는 하나의 actor에 의해서만 변경되어야 한다.
  - 서로 다른 속도와 이유로 변경되는 행위를 분리해야 한다.
- OCP(Open Close Principle)
  - 확장에 열려있고 변경에 닫혀 있어야 한다.
  - 기존 코드를 수정하기보다 새로운 객체로 교체할 수 있는 확장성을 가져야 한다.
- LSP(Liskov Subsitution Principle)
  - 어떤 하위 타입으로도 치환할 수 있어야 한다.
- ISP(Interface Segregation Principle)
  - 실제로 사용하지 않는 것에 의존하지 않도록 인터페이스로 분리해야 한다.
- DIP(Dependency Inversion Principle)
  - 구체 컴포넌트가 항상 추상 컴포넌트에 의존하도록 의존성 방향을 제어 흐름에 역전시켜야 한다.

### Component Cohesion

- REP(Reuse/Release Equivalence Principle)
  - 재사용 단위는 릴리스 단위와 같다.
  - 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 한다.
- CCP(Common Closure Principle)
  - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶는다.
  - 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리한다.
- CRP(Common Reuse Principle)
  - 필요하지 않는 것에 의존하지 않아야 한다.
  - 같이 재사용되는 경향이 있는 클래스와 모듈을 같은 컴포넌트에 포함해야 한다.

### Component Coupling

- ADP(Acyclic Dependencies Principle)
  - 의존성 그래프가 순환하지 않도록 설계하라
  - 순환이 발생하면 의존성을 끊을 수 없고, 순환을 만드는 컴포넌트들이 하나의 거대한 컴포넌트가 되어 유지보수를 어렵게 만든다.
  - DIP를 사용하는 등 순환을 끊어야 한다.
- SDP(Stable Dependencies Principle)
  - 더 안정된 방향으로 의존하라
  - 안정된 컴포넌트 : 불안정성 `I = out / (in + out)`에 대해 `I = 0`인 컴포넌트
  - Out이 0이다 == 다른 컴포넌트에 의존하지 않는다 == 외부 요소에 의해 변경되지 않는다 == 안정되었다.
- SAP(Stable Abstractions Principle)
  - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
  - 추상화 정도 `A = Na / Nc`에 대해 `I`와 `A` 사이에 주계열 그래프가 형성된다.
  - 주계열로부터의 거리 `D = |A + I - 1|`에 대해 `D`가 0에 가까울 수록 이상적이다.
- SDP와 SAP : **안정된 컴포넌트는 추상 컴포넌트여야 한다고 말하며, 항상 추상 컴포넌트에 의존해야 한다.**

### 비교

- SRP와 CCP : 동일한 시점에 동일한 이유로 변경되는 것들을 하나로 묶어라
  - SRP : 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라
  - CCP : 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라
- ISP와 CRP : 필요하지 않은 것에 의존하지 말라
  - ISP : 사용하지 않는 메서드가 있는 클래스에 의존하지 말아라
  - CRP : 사용하지 않는 클래스가 있는 컴포넌트에 의존하지 말아라

## 17장. 경계: 선 긋기

- 아키텍처는 '선 긋기' 기술
- 선(또는 경계) : 고수준 업무 규칙을 저수준 세부사항(UI, DB 등)과 분리시키는 경계
- UI, DB 등은 외부 요인에 의해 비교적 자주 변경되는데, 이 변경사항이 핵심 업무 규칙에까지 영향을 주지 않도록 격리시키는 것
- 경계를 구분함으로써 고수준 컴포넌트가 저수준 컴포넌트를 플러그인처럼 사용하게 됨 => 플러그인 아키텍처
- 저수준 컴포넌트를 플러그인처럼 사용하므로, 저수준 컴포넌트의 구체적인 구현 방식에 대한 결정을 최대한 뒤로 미룰 수 있다. 
  - Realm과 CoreData 중 어떤 것을 사용할 것인지?
  - UIKit과 SwiftUI중 어떤 것을 사용해서 UI를 개발할 것인지?
- 이 과정에서 두 가지 원칙이 적용됨
  - DIP : 고수준 컴포넌트가 저수준 컴포넌트를 사용할 때, 제어 흐름과 반대되는 의존성 방향을 갖도록 만들어서 분리한다.
  - SAP : 불안정한 저수준 컴포넌트가 안정된 고수준의 추상 컴포넌트에 의존하도록 만든다.

## 18장. 경계 해부학

- 경계를 사용해서 변경사항이 고수준 컴포넌트로 전파되는것을 막을 때, OOP의 다형성이 중요한 역할을 함
- OOP의 동적 다형성은 의존성 역전을 안전하고 쉽게 구현할 수 있게 함
- 의존성을 역전시킬 때, 인터페이스에서 필요한 데이터 구조는 호출하는 쪽에서 정의하게 됨. => DS는 고수준 컴포넌트에 포함된다.
- 경계는 고수준 컴포넌트를 저수준 세부사항으로부터 독립적으로 유지할 수 있게 해 준다.

## 19장. 정책과 수준

- 정책 : 소프트웨어 시스템의 동작을 설명하는 단위
- 수준 : 입력 및 출력까지의 거리. 멀리 떨어져 있을 수록 고수준.
  - 스마트폰에서 입력과 출력은 UI, DB, Server 등에 해당 -> 저수준
  - 업무 규칙은 상대적으로 고수준에 해당
- 동일한 이유로 동일한 시점에 변경되는 정책들을 같은 컴포넌트로 묶어야 한다.
- 컴포넌트들 사이의 의존성 관계는 비순환 방향 그래프를 형성하며, 의존성은 항상 저수준에서 고수준을 향하도록 설계해야 한다.
  - 즉, 의존성은 '수준'에 따라 결합된다.
- 모든 의존성이 저수준에서 고수준으로 향하는 지점에서 수준을 나누는 경계가 그어진다.

## 20장. 업무 규칙

- 소프트웨어와 관계 없이 사업적 수익을 얻거나 비용을 줄일 수 있는 규칙
- 엔티티(Entity) : 사업 특화 업무 규칙
  - 핵심 업무 규칙 : 사업 자체에 핵심적이며 규칙을 자동화하는 시스템이 없더라도 존재하는 규칙 (e.g. 대출에 N%의 이자를 부과한다.)
  - 핵심 업무 데이터 : 핵심 업무 규칙이 존재하기 위해 필요한 데이터 (e.g. 이자율, 대출 잔액 등)
  - 엔티티는 핵심 업무 규칙(method)과 핵심 업무 데이터(property)를 묶어놓은 독립된 모듈(struct, object)
  - DB, UI, third party framework 등 외부 요인에 의해 변경되어서는 안됨
- 유스케이스(Use case) : 애플리케이션 특화 업무 규칙
  - 엔티티를 언제, 어떻게 호출할지 명시하여 사용자와 상호작용하는 방식을 규정한다.
  - (e,g, 시스템에서 신상정보 화면을 모두 채우고 신용도가 검증된 후에 대출 견적 화면으로 이동한다.)
  - UI에 독립적이므로, use case만 봐서는 어떤 형식의 프로그램인지 알 수 없다. (e.g. 앱인지, 웹인지, 순수 서비스인지)
- 엔티티는 유스케이스에 대해 아무것도 알지 못한다.
  - 유스케이스는 입출력에 더 가까이 위치하므로 엔티티보다 저수준
  - 저수준 -> 고수준 으로 의존성을 설계해야 하므로 엔티티는 유스케이스에 대해 아무 것도 알 수 없다.
- 유스케이스는 요청(request) 및 응답(response) 모델을 독립적으로 가져야 한다.
  - 엔티티와 요청/응답 모델이 똑같이 생겼지만, 같이 사용하면 안된다.
  - 이들은 완전히 다른 속도와 이유로 변경되므로 CCP와 SRP에 위배된다.

## 21장. 소리치는 아키텍처

- 아키텍처는 애플리케이션의 유스케이스에 대해 소리쳐야 한다.
- 아키텍처가 유스케이스를 중심에 두어야 프레임워크, DB, Server, UI 등 세부사항을 오랫동안 선택사항으로 남겨둘 수 있다.
- 프레임워크 없이 애플리케이션의 모든 유스케이스에 대해 단위 테스트를 할 수 있어야 한다. -> Testability
- 새로 합류한 프로그래머는 시스템이 어떻게 전달될지 알지 못한 상태에서도 모든 유스케이스를 이해할 수 있어야 한다.