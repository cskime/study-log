# 빠져 있는 장

> Clean Architecture 6부 34장

- 이 장에서는 시몬 브라운이라는 엔지니어가 엉클 밥이 제안하는 클린 아키텍처에 자신의 경험을 더해서 설명해 준다.
- 일반적으로 iOS 개발을 하면 패키지 단위로 나누지 않고 파일 단위로만 코드를 분리하곤 하는데, 이것을 생각하면 이 장에서 설명하는 내용이 크게 와닿지 않는 것 같다.
- 코드 단위로만 분리해 두면, Swift는 기본적으로 internal access로 설정되므로 어디서나 접근할 수 있게 되어 컴파일 레벨에서 아키텍처를 보호하지 못한다.
- iOS 개발을 할 때도 모듈화를 통해 응집도를 높이는 시도를 하는데, 이렇게 다른 패키지(workspace)로 나눠서 public, open access까지 사용하는 경우를 떠올리며 읽어야 할 것 같다.

## 계층 기반 패키지

<p align="center"><img src="img/detail-others-layer-base-package.png" width="200"></p>

- 수평 계층형 아키텍처(계층 기반 패키지) : 해당 코드가 하는 일에 기반해서 분리하는 방법
- 웹, '업무 규칙', 영속성 코드를 위한 계층이 각각 하나씩 존재한다.
    - 코드를 '**계층**'이라는 수평 조각으로 나눈다.
    - 각 계층은 유사한 종류의 것들을 묶는다.
    - 계층은 반드시 바로 아래 계층에만 의존해야 한다. 즉, **의존성은 모두 아래로 향한다.**
- 이 방법은 개발을 처음 시작했을 때는 유용하지만, 소프트웨어가 커지고 복잡해지면 또 다시 모듈화를 고민하게 된다.
- 계층형 아키텍처는 **업무 도메인에 대해 아무것도 말해주지 않는다**는 문제도 있다.
    - 단순히 유사한 성격의 코드를 묶어 놓은 것이므로, 도메인이 드러나지 않는다.

## 기능 기반 패키지

<p align="center"><img src="img/detail-others-function-base-package.png" width="200"></p>

- 서로 연관된 '**기능, 도메인 개념**'에 기반하여 코드를 수직으로 나누는 방식
- 모든 타입이 하나의 패키지에 속하며, **패키지 이름은 그 안에 담긴 개념을 반영해서 짓는다.**
- 코드의 상위 수준 구조가 **업무 도메인에 대해 무언가를 알려주게 된다.** 
    - 위 예시에서는 패키지 이름만 봐도 주문과 관련한 무언가를 한다는 것을 알 수 있다.
    - e.g. `com.mycompany.myapp.orders`
- 위 예시에서, '주문 조회하기' use case가 변경될 경우 변경해야 할 코드를 찾는 작업이 쉬워진다.
    - 어떤 기능과 관련된 코드는 하나의 패키지에 모두 들어있다.
    - 어떤 패키지는 이름만 보고 어떤 기능을 담고 있는지 알 수 있다.

## 포트와 어댑터

<p align="center"><img src="img/detail-others-port-and-adapter.png" width="300"></p>

- 'Ports and Adapters' 또는 'Hexagonal Architecture', '경계, 컨트롤러, 엔티티(BCE)' 등의 방식으로 접근하는 이유
- 업무/도메인에 초점을 둔 코드가 **프레임워크나 데이터베이스같은 기술적인 세부 구현과 독립적이며 분리된 아키텍처**를 만들기 위함
- 즉, '내부(도메인)'와 '외부(인프라)'로 구성된다.
    - '내부' 영역은 도메인 모두를 포함한다.
    - '외부' 영역은 UI, DB, 서드파티 등과의 상호작용을 포함한다.
    - **반드시 '외부'가 '내부'에 의존해야 한다. (의존성이 밖에서 안으로 향해야 한다).**
- 아래는 이런 방식으로 '주문 조회하기' use case를 구현한 모습이다.

<p align="center"><img src="img/detail-others-inner-outer-usecase.png" width="200"></p>

- 다른 패키지와 다르게, repository가 구현하는 인터페이스의 이름이 `~Repository`가 아니라 `Orders`이다.
    - 도메인 주도 설계에서 비롯한 명명법
    - 내부에 존재하는 모든 것의 이름은 반드시 '유비쿼터스 도메인 언어(Ubiquitous Domain Language)' 관점에서 기술하라는 것
    - 우리는 '주문'에 대해 말하는 것이지 '주문 리포지터리'에 대해 말하는 것이 아니다.

## 컴포넌트 기반 패키지

- 기존에 사용하던 패키지 분리 방법들은 임의로 의도치 않은 방식으로 의존성을 추가할 수 있는 여지가 있다.
- 아래 그림과 같이, 인접한 계층을 건너 뛰어서 의존성을 추가할 여지가 생긴다.

<p align="center"><img src="img/detail-others-component-base-package-wrong.png" width="300"></p>

- 이러한 조직화는 계층이 인접한 계층을 건너뛰는 일이 허용되기 때문에 "완화된 계층형 아키텍처"라고도 부른다.
- 이런 일을 막기 위해서는 새로운 아키텍처 원칙인데, 개발자에 대한 믿음은 그리 오래 가지 못한다.
    - '웹 컨트롤러는 절대로 리포지터리에 직접 접근해서는 안 된다.' 같은 원칙
    - 개발자는 이를 명심하고 따를 수 있지만, 언제든 실수할 수 있다.
- 정적 분석 도구 등을 사용해서 **컴파일러를 사용하여 아키텍처를 강제하는 방식**을 선호한다.
- '**컴포넌트 기반 패키지**'는 컴파일러에 의해 아키텍처가 강제되도록 만든다.
- 큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 패키지로 묶는 데 주안점을 둔다.
- 사용자 인터페이스(UI)는 큰 단위의 컴포넌트로부터 분리해서 유지한다.

<p align="center"><img src="img/detail-others-component-base-package.png" width="200"></p>

- 이 접근법에서는 **업무 로직과 영속성 관련 코드를 하나로 묶는다**.
    - 이 묶음을 '**컴포넌트**'라고 부른다.
    - 엉클 밥의 '컴포넌트 정의'
        - 컴포넌트는 배포 단위이다.
        - 컴포넌트는 시스템의 구성 요소로, 배포할 수 있는 가장 작은 단위이다.
    - 새로운 정의
        - 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음
        - 애플리케이션과 같은 실행 환경 내부에 존재한다.
- 컴포넌트 기반 패키지의 이점 중 하나는, 주문과 관련된 무언가를 코딩할 때 오직 한 곳(OrdersComponent)만 둘러보면 된다는 점이다.
    - 컴포넌트 내부에서는 여전히 업무 규칙과 데이터 영속성이 분리되어 있다.
    - 이것은 컴포넌트의 세부사항으로, 사용자(UI)는 알 필요가 없다.

## 조직화 vs. 캡슐화

<p align="center"><img src="img/detail-others-organization-capsulation.png" width="700"></p>

- 계층 기반 패키지
    - `OrdersService`와 `OrdersRepository` 인터페이스는 외부 패키지 클래스로부터 자신이 속산 패키지 내부로 들어오는 의존성이 존재하므로 `public`으로 선언되어야 한다.
    - `OrdersServiceImpl`과 `JdbcOrdersRepository`는 보다 재한적으로 선언할 수 있다. (Package protected)
- 기능 기반 패키지
    - `OrdersController`가 패키지로 들어올 수 있는 유일한 통로를 제공하므로, 나머지는 모두 package protected로 지정할 수 있다.
    - 패키지 외부에서는 `OrdersController`를 통하지 않고는 패키지 내부로 접근할 방법이 없다.
- 포트와 어댑터
    - `OrdersService`와 `Orders` 인터페이스가 외부로부터 들어오는 의존성을 가지므로 `public`으로 선언한다.
    - 이 의존성은 런타임에 주입할 수 있다.
    - 나머지 구현체 클래스들은 `protected`로 선언한다.
- 컴포넌트 기반 패키지
    - `OrderController`에서 `OrdersComponent` 인터페이스로 향하는 의존성을 가지므로, `public`으로 선언한다.
    - 이외 나머지 클래스들은 `protected`로 선언한다.
    - 외부에서 `OrdersRepository` 인터페이스나 구현체를 직접 사용할 수 있는 방법이 전혀 없게 된다.
    - **컴파일러의 도움을 받아서 '컴포넌트 기반 패키지' 아키텍처 접근법을 강제할 수 있다.**

## 결론

- 최적의 설계를 꾀했더라도, 구현 전략에 얽힌 복잡성을 고려하지 않으면 설계가 순식간에 망가질 수도 있다.
- 코드의 조직화, 런타임과 컴파일타임에 어떤 결합 분리 모드를 적용할지 고민해야 한다.
- 가능하면 선택사항을 열어두되, 실용주의적으로 행해야 한다. (일정, 예산, 팀 규모, 기술 수준, 해결책의 복잡성 등을 함께 고려해야 한다.)
- 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받는게 좋다.